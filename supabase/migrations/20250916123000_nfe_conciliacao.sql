-- NFe ↔ Contas/Parcelas — conciliação e auditoria
-- v1.1 - 2025-09-16 (idempotente; cria nfe_data se não existir)

BEGIN;

-- 0) Criar nfe_data (mínima) se não existir
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.tables
    WHERE table_schema='public' AND table_name='nfe_data'
  ) THEN
    CREATE TABLE public.nfe_data (
      chave_acesso TEXT PRIMARY KEY,
      emitente TEXT,
      destinatario TEXT,
      valores JSONB
    );
  END IF;
END
$$;

-- 0.1) Unique em chave (idempotente)
CREATE UNIQUE INDEX IF NOT EXISTS uq_nfe_data_chave ON public.nfe_data(chave_acesso);

-- 1) Tabela de vínculo NFe ↔ Parcela
CREATE TABLE IF NOT EXISTS public.nfe_parcela_link (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  chave_acesso TEXT NOT NULL,
  parcela_id BIGINT NOT NULL,
  criado_em TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT uq_nfe_parcela UNIQUE (chave_acesso, parcela_id)
);

-- 1.1) FK para parcela, se a tabela existir
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='parcelas_conta_pagar') THEN
    BEGIN
      ALTER TABLE public.nfe_parcela_link
        ADD CONSTRAINT fk_nfe_parcela_link_parcela
        FOREIGN KEY (parcela_id) REFERENCES public.parcelas_conta_pagar(id) ON DELETE CASCADE;
    EXCEPTION WHEN duplicate_object THEN
      NULL;
    END;
  END IF;
END
$$;

-- 2) Views de auditoria
CREATE OR REPLACE VIEW public.vw_nfe_pendentes AS
SELECT n.*
FROM public.nfe_data n
LEFT JOIN public.nfe_parcela_link l ON l.chave_acesso = n.chave_acesso
WHERE l.id IS NULL;

CREATE OR REPLACE VIEW public.vw_nfe_conciliada AS
WITH soma AS (
  SELECT l.chave_acesso, sum(p.valor_parcela) AS total_parcelas, count(*) AS qtd_parcelas
  FROM public.nfe_parcela_link l
  JOIN public.parcelas_conta_pagar p ON p.id = l.parcela_id
  GROUP BY l.chave_acesso
)
SELECT 
  n.chave_acesso,
  n.emitente,
  n.destinatario,
  COALESCE( (n.valores->>'total')::numeric, NULL ) AS total_nfe,
  s.total_parcelas,
  s.qtd_parcelas,
  (COALESCE((n.valores->>'total')::numeric, 0) - COALESCE(s.total_parcelas, 0)) AS diferenca
FROM public.nfe_data n
LEFT JOIN soma s ON s.chave_acesso = n.chave_acesso;

-- 3) Função: conciliar NFe
CREATE OR REPLACE FUNCTION public.fn_conciliar_nfe(
  p_chave TEXT,
  p_conta_id BIGINT,
  p_criar_conta BOOLEAN DEFAULT FALSE
)
RETURNS TABLE (chave_acesso TEXT, conta_id BIGINT, parcela_id BIGINT)
LANGUAGE plpgsql
AS $fn$
DECLARE
  v_total NUMERIC;
  v_conta BIGINT;
  v_parcela BIGINT;
BEGIN
  IF NOT EXISTS (SELECT 1 FROM public.nfe_data WHERE chave_acesso = p_chave) THEN
    RAISE EXCEPTION 'NFe com chave % não encontrada', p_chave USING ERRCODE = 'P0002';
  END IF;

  SELECT (valores->>'total')::numeric INTO v_total
  FROM public.nfe_data WHERE chave_acesso = p_chave;

  IF p_conta_id IS NULL AND p_criar_conta IS TRUE THEN
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='contas_pagar_corporativas')
       AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='parcelas_conta_pagar')
    THEN
      INSERT INTO public.contas_pagar_corporativas (filial_id, credor_id, descricao, valor_total, categoria_id, dt_vencimento)
      VALUES (NULL, NULL, CONCAT('NFe ', p_chave), COALESCE(v_total, 0), NULL, current_date)
      RETURNING id INTO v_conta;

      INSERT INTO public.parcelas_conta_pagar (conta_pagar_id, data_vencimento, valor_parcela, status)
      VALUES (v_conta, current_date, COALESCE(v_total, 0), 'a_vencer')
      RETURNING id INTO v_parcela;
    ELSE
      RAISE EXCEPTION 'Tabelas de contas/parcelas não existem; informe p_conta_id ou crie as tabelas' USING ERRCODE = 'P0003';
    END IF;

  ELSIF p_conta_id IS NOT NULL THEN
    v_conta := p_conta_id;

    SELECT p.id
    INTO v_parcela
    FROM public.parcelas_conta_pagar p
    WHERE p.conta_pagar_id = v_conta
      AND p.id NOT IN (SELECT parcela_id FROM public.nfe_parcela_link WHERE chave_acesso = p_chave)
      AND p.id NOT IN (SELECT parcela_id FROM public.nfe_parcela_link)
    ORDER BY p.data_vencimento
    LIMIT 1;

    IF v_parcela IS NULL THEN
      RAISE EXCEPTION 'Nenhuma parcela disponível para vincular na conta %', v_conta USING ERRCODE = 'P0004';
    END IF;

  ELSE
    RAISE EXCEPTION 'Informe p_conta_id ou habilite p_criar_conta' USING ERRCODE = '22023';
  END IF;

  INSERT INTO public.nfe_parcela_link (chave_acesso, parcela_id)
  VALUES (p_chave, v_parcela)
  ON CONFLICT (chave_acesso, parcela_id) DO NOTHING;

  RETURN QUERY
  SELECT p_chave, v_conta, v_parcela;
END
$fn$;

-- 4) Funções auxiliares
CREATE OR REPLACE FUNCTION public.fn_desfazer_conciliacao_nfe(p_chave TEXT)
RETURNS INTEGER
LANGUAGE plpgsql
AS $fn$
DECLARE v_qtd INT;
BEGIN
  DELETE FROM public.nfe_parcela_link WHERE chave_acesso = p_chave;
  GET DIAGNOSTICS v_qtd = ROW_COUNT;
  RETURN v_qtd;
END
$fn$;

CREATE OR REPLACE FUNCTION public.fn_nfe_pendentes()
RETURNS SETOF public.nfe_data
LANGUAGE sql
AS $fn$
  SELECT * FROM public.vw_nfe_pendentes
$fn$;

-- 5) RLS básico
ALTER TABLE public.nfe_parcela_link ENABLE ROW LEVEL SECURITY;

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='nfe_parcela_link' AND policyname='nfe_parcela_link_select_auth') THEN
    CREATE POLICY nfe_parcela_link_select_auth ON public.nfe_parcela_link
      FOR SELECT TO authenticated USING (true);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='nfe_parcela_link' AND policyname='nfe_parcela_link_mod_admin') THEN
    CREATE POLICY nfe_parcela_link_mod_admin ON public.nfe_parcela_link
      FOR ALL TO authenticated
      USING (public.is_admin()) WITH CHECK (public.is_admin());
  END IF;
END
$$;

COMMIT;
