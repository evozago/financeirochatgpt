-- financeirolb: recorrentes (cadastro + função + agendamento robusto)
-- v1.3 - 2025-09-17

BEGIN;

-- ================================================
-- Tabelas base (idempotente)
-- ================================================
CREATE TABLE IF NOT EXISTS public.recorrentes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  filial_id BIGINT,
  credor_id BIGINT REFERENCES public.entidades(id),
  categoria_id BIGINT,
  descricao TEXT NOT NULL,
  valor NUMERIC(14,2) NOT NULL CHECK (valor >= 0),
  dia_vencimento INT NOT NULL CHECK (dia_vencimento BETWEEN 1 AND 28),
  ativo BOOLEAN NOT NULL DEFAULT TRUE,
  criado_em TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.recorrentes_log (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ano INT NOT NULL,
  mes INT NOT NULL CHECK (mes BETWEEN 1 AND 12),
  executado_em TIMESTAMPTZ NOT NULL DEFAULT now(),
  total_gerado INT NOT NULL
);

-- ================================================
-- (Opcional) RLS DEV — libera authenticated para ler/escrever
-- Ajuste depois para sua ACL por organização/filial
-- ================================================
ALTER TABLE public.recorrentes     ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.recorrentes_log ENABLE ROW LEVEL SECURITY;

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='recorrentes' AND policyname='recorrentes_all_auth') THEN
    DROP POLICY recorrentes_all_auth ON public.recorrentes;
  END IF;
  IF EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='recorrentes_log' AND policyname='recorrentes_log_all_auth') THEN
    DROP POLICY recorrentes_log_all_auth ON public.recorrentes_log;
  END IF;

  CREATE POLICY recorrentes_all_auth
    ON public.recorrentes
    FOR ALL
    TO authenticated
    USING (true)
    WITH CHECK (true);

  CREATE POLICY recorrentes_log_all_auth
    ON public.recorrentes_log
    FOR ALL
    TO authenticated
    USING (true)
    WITH CHECK (true);
END$$;

-- ================================================
-- Função de geração mensal
-- - Parâmetros: pano, pmes
-- - Gera 1 conta + 1 parcela por recorrente ativo
-- - Loga quantidade efetivamente criada
-- ================================================
CREATE OR REPLACE FUNCTION public.gerar_recorrentes(pano INT, pmes INT)
RETURNS VOID
LANGUAGE plpgsql
AS $fn$
DECLARE 
  rec RECORD;
  nova_conta_id BIGINT;
  venc DATE;
  v_count INTEGER := 0;
  has_contas  BOOLEAN;
  has_parcelas BOOLEAN;
  has_categoria_col BOOLEAN;
BEGIN
  -- validação básica
  IF pano IS NULL OR pmes IS NULL OR pmes < 1 OR pmes > 12 THEN
    RAISE EXCEPTION 'Parâmetros inválidos: ano %, mes %', pano, pmes;
  END IF;

  -- verifica existência das tabelas necessárias
  SELECT EXISTS (
    SELECT 1 FROM information_schema.tables
    WHERE table_schema='public' AND table_name='contas_pagar_corporativas'
  ) INTO has_contas;

  SELECT EXISTS (
    SELECT 1 FROM information_schema.tables
    WHERE table_schema='public' AND table_name='parcelas_conta_pagar'
  ) INTO has_parcelas;

  IF NOT has_contas OR NOT has_parcelas THEN
    -- sem as tabelas principais, não há o que gerar
    INSERT INTO public.recorrentes_log (ano, mes, total_gerado)
    VALUES (pano, pmes, 0);
    RETURN;
  END IF;

  -- existe coluna categoria_id em contas_pagar_corporativas?
  SELECT EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema='public'
      AND table_name='contas_pagar_corporativas'
      AND column_name='categoria_id'
  ) INTO has_categoria_col;

  -- percorre recorrentes ativos
  FOR rec IN 
    SELECT * FROM public.recorrentes WHERE ativo = TRUE
  LOOP
    venc := make_date(pano, pmes, rec.dia_vencimento);

    -- cria conta (com ou sem categoria_id, conforme a estrutura da sua tabela)
    IF has_categoria_col THEN
      INSERT INTO public.contas_pagar_corporativas
        (filial_id, credor_id, descricao, valor_total, categoria_id, dt_vencimento, status)
      VALUES
        (rec.filial_id, rec.credor_id, concat(rec.descricao, ' ', to_char(venc, 'MM/YYYY')), rec.valor, rec.categoria_id, venc, 'aberta')
      RETURNING id INTO nova_conta_id;
    ELSE
      INSERT INTO public.contas_pagar_corporativas
        (filial_id, credor_id, descricao, valor_total, dt_vencimento, status)
      VALUES
        (rec.filial_id, rec.credor_id, concat(rec.descricao, ' ', to_char(venc, 'MM/YYYY')), rec.valor, venc, 'aberta')
      RETURNING id INTO nova_conta_id;
    END IF;

    -- cria 1 parcela (num_parcela = 1)
    INSERT INTO public.parcelas_conta_pagar
      (conta_pagar_id, num_parcela, data_vencimento, valor_parcela, status)
    VALUES
      (nova_conta_id, 1, venc, rec.valor, 'a_vencer');

    v_count := v_count + 1;
  END LOOP;

  -- grava log com a quantidade efetivamente criada
  INSERT INTO public.recorrentes_log (ano, mes, total_gerado)
  VALUES (pano, pmes, v_count);
END
$fn$;

COMMIT;

-- ================================================
-- Tentar habilitar pg_cron (não quebra se não tiver permissão)
-- ================================================
DO $blk$
BEGIN
  BEGIN
    EXECUTE 'CREATE EXTENSION IF NOT EXISTS pg_cron';
  EXCEPTION WHEN OTHERS THEN
    -- sem permissão? tudo bem, só não agenda
    NULL;
  END;
END
$blk$;

-- ================================================
-- Tentar agendar o job; se pg_cron não existir, ignorar; se já existir, ignorar
-- ================================================
DO $job$
BEGIN
  BEGIN
    PERFORM cron.schedule(
      'financeirolb_recorrentes_mensal',
      '10 0 1 * *',
      $cmd$SELECT public.gerar_recorrentes(EXTRACT(YEAR FROM CURRENT_DATE)::int,
                                           EXTRACT(MONTH FROM CURRENT_DATE)::int)$cmd$
    );
  EXCEPTION
    WHEN undefined_function OR invalid_schema_name OR undefined_table OR duplicate_function OR unique_violation THEN
      -- sem pg_cron ou job já criado: ok
      NULL;
    WHEN OTHERS THEN
      -- qualquer outro erro: não travar migration
      NULL;
  END;
END
$job$;
