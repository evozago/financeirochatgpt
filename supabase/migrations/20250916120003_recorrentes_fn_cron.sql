-- financeirolb: recorrentes (cadastro + função + agendamento robusto)
-- v1.2 - 2025-09-16

BEGIN;

-- Tabelas (idempotente)
CREATE TABLE IF NOT EXISTS public.recorrentes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  filial_id BIGINT,
  credor_id BIGINT REFERENCES public.entidades(id),
  categoria_id BIGINT,
  descricao TEXT NOT NULL,
  valor NUMERIC(14,2) NOT NULL CHECK (valor >= 0),
  dia_vencimento INT NOT NULL CHECK (dia_vencimento BETWEEN 1 AND 28),
  ativo BOOLEAN NOT NULL DEFAULT TRUE,
  criado_em TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.recorrentes_log (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ano INT NOT NULL,
  mes INT NOT NULL CHECK (mes BETWEEN 1 AND 12),
  executado_em TIMESTAMPTZ NOT NULL DEFAULT now(),
  total_gerado INT NOT NULL
);

-- Função de geração mensal (idempotente)
CREATE OR REPLACE FUNCTION public.gerar_recorrentes(pano INT, pmes INT)
RETURNS VOID
LANGUAGE plpgsql
AS $fn$
DECLARE 
  rec RECORD;
  nova_conta_id BIGINT;
  venc DATE;
BEGIN
  FOR rec IN 
    SELECT * FROM public.recorrentes WHERE ativo = TRUE
  LOOP
    venc := make_date(pano, pmes, rec.dia_vencimento);

    IF EXISTS (
      SELECT 1 FROM information_schema.tables
      WHERE table_schema='public' AND table_name='contas_pagar_corporativas'
    ) THEN
      INSERT INTO public.contas_pagar_corporativas (filial_id, credor_id, descricao, valor_total, categoria_id, dt_vencimento)
      VALUES (rec.filial_id, rec.credor_id, concat(rec.descricao, ' ', to_char(venc, 'MM/YYYY')), rec.valor, rec.categoria_id, venc)
      RETURNING id INTO nova_conta_id;

      IF EXISTS (
        SELECT 1 FROM information_schema.tables
        WHERE table_schema='public' AND table_name='parcelas_conta_pagar'
      ) THEN
        INSERT INTO public.parcelas_conta_pagar (conta_pagar_id, data_vencimento, valor_parcela, status)
        VALUES (nova_conta_id, venc, rec.valor, 'a_vencer');
      END IF;
    END IF;
  END LOOP;

  INSERT INTO public.recorrentes_log (ano, mes, total_gerado)
  VALUES (pano, pmes, (SELECT COUNT(*) FROM public.recorrentes WHERE ativo = TRUE));
END
$fn$;

COMMIT;

-- Tentar habilitar pg_cron (não quebra se não tiver permissão)
DO $blk$
BEGIN
  BEGIN
    EXECUTE 'CREATE EXTENSION IF NOT EXISTS pg_cron';
  EXCEPTION WHEN OTHERS THEN
    -- sem permissão? tudo bem, só não agenda
    NULL;
  END;
END
$blk$;

-- Tentar agendar o job; se pg_cron não existir, ignorar; se já existir, ignorar
DO $job$
BEGIN
  BEGIN
    PERFORM cron.schedule(
      'financeirolb_recorrentes_mensal',
      '10 0 1 * *',
      $cmd$SELECT public.gerar_recorrentes(EXTRACT(YEAR FROM CURRENT_DATE)::int,
                                           EXTRACT(MONTH FROM CURRENT_DATE)::int)$cmd$
    );
  EXCEPTION
    WHEN undefined_function OR invalid_schema_name OR undefined_table OR duplicate_function OR unique_violation THEN
      -- sem pg_cron ou job já criado: ok
      NULL;
    WHEN OTHERS THEN
      -- qualquer outro erro: não travar migration
      NULL;
  END;
END
$job$;
