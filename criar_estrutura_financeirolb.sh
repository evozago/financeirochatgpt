#!/usr/bin/env bash
set -euo pipefail

# === Criar pastas ===
mkdir -p supabase/migrations
mkdir -p data/seed
mkdir -p docs

TS="20250915"

# === 01) Entidades canônicas + Papéis (idempotente) ===
cat > "supabase/migrations/${TS}_01_entities_and_roles.sql" <<'SQL'
-- financeirolb: entidades canônicas (PF/PJ) + papéis
-- Idempotente. Seguro para rodar em bancos já existentes.
-- v1.0 - 2025-09-15

BEGIN;

-- 1) Tabela unificada de entidades (PF e PJ)
CREATE TABLE IF NOT EXISTS public.entidades (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nome TEXT NOT NULL,
  tipo_pessoa VARCHAR(8) NOT NULL CHECK (tipo_pessoa IN ('FISICA','JURIDICA')),
  documento VARCHAR(32),   -- CPF ou CNPJ sem máscara
  email TEXT,
  telefone TEXT,
  ativo BOOLEAN NOT NULL DEFAULT TRUE,
  criado_em TIMESTAMPTZ NOT NULL DEFAULT now(),
  atualizado_em TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- gatilho simples para updated_at
CREATE OR REPLACE FUNCTION public.set_atualizado_em()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  NEW.atualizado_em := now();
  RETURN NEW;
END; $$;

DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_trigger WHERE tgname = 'tg_entidades_set_atualizado_em'
  ) THEN
    CREATE TRIGGER tg_entidades_set_atualizado_em
    BEFORE UPDATE ON public.entidades
    FOR EACH ROW EXECUTE FUNCTION public.set_atualizado_em();
  END IF;
END $$;

-- 2) Enum de papéis e tabela de mapeamento
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'tipo_papel') THEN
    CREATE TYPE public.tipo_papel AS ENUM ('FORNECEDOR','CLIENTE','FUNCIONARIO');
  END IF;
END $$;

CREATE TABLE IF NOT EXISTS public.entidade_papel (
  entidade_id BIGINT NOT NULL REFERENCES public.entidades(id) ON DELETE CASCADE,
  papel public.tipo_papel NOT NULL,
  atribuicao_em TIMESTAMPTZ NOT NULL DEFAULT now(),
  PRIMARY KEY (entidade_id, papel)
);

-- 3) (Opcional) Tabela de referência "papeis" para UI
CREATE TABLE IF NOT EXISTS public.papeis (
  nome public.tipo_papel PRIMARY KEY
);
INSERT INTO public.papeis (nome)
SELECT unnest(enum_range(NULL::public.tipo_papel))
ON CONFLICT (nome) DO NOTHING;

-- 4) Migração (se existirem tabelas antigas)
-- 4.1) Migrar entidades de 'entidades_corporativas' para 'entidades'
DO $$
DECLARE
  _has_old BOOLEAN;
BEGIN
  SELECT EXISTS (
    SELECT 1 FROM information_schema.tables
    WHERE table_schema='public' AND table_name='entidades_corporativas'
  ) INTO _has_old;

  IF _has_old THEN
    INSERT INTO public.entidades (id, nome, tipo_pessoa, documento, email, telefone, ativo, criado_em, atualizado_em)
    SELECT ec.id,
           ec.nome,
           ec.tipo_pessoa,
           COALESCE(NULLIF(ec.cnpj,''), NULLIF(ec.cpf,'')) AS documento,
           ec.email,
           ec.telefone,
           COALESCE(ec.ativo, TRUE),
           now(), now()
    FROM public.entidades_corporativas ec
    ON CONFLICT (id) DO NOTHING;

    -- Papéis: assume colunas booleanas fornecedor/cliente/funcionario
    INSERT INTO public.entidade_papel (entidade_id, papel)
    SELECT ec.id, 'FORNECEDOR'::public.tipo_papel FROM public.entidades_corporativas ec WHERE COALESCE(ec.fornecedor, FALSE) = TRUE
    ON CONFLICT DO NOTHING;
    INSERT INTO public.entidade_papel (entidade_id, papel)
    SELECT ec.id, 'CLIENTE'::public.tipo_papel FROM public.entidades_corporativas ec WHERE COALESCE(ec.cliente, FALSE) = TRUE
    ON CONFLICT DO NOTHING;
    INSERT INTO public.entidade_papel (entidade_id, papel)
    SELECT ec.id, 'FUNCIONARIO'::public.tipo_papel FROM public.entidades_corporativas ec WHERE COALESCE(ec.funcionario, FALSE) = TRUE
    ON CONFLICT DO NOTHING;
  END IF;
END $$;

-- 4.2) Migrar vendedoras (se existir) para entidades com papel FUNCIONARIO
DO $$
DECLARE
  _has_vend BOOLEAN;
BEGIN
  SELECT EXISTS (
    SELECT 1 FROM information_schema.tables
    WHERE table_schema='public' AND table_name='vendedoras'
  ) INTO _has_vend;

  IF _has_vend THEN
    -- Insere entidades pela chave documento (cpf). Se nao houver cpf, usa nome como fallback (não ideal)
    INSERT INTO public.entidades (nome, tipo_pessoa, documento, email, telefone, ativo)
    SELECT v.nome, 'FISICA', NULLIF(v.cpf,''), NULLIF(v.email,''), NULLIF(v.telefone,''), COALESCE(v.ativa, TRUE)
    FROM public.vendedoras v
    ON CONFLICT (documento) DO NOTHING;

    -- vincula papel FUNCIONARIO
    INSERT INTO public.entidade_papel (entidade_id, papel)
    SELECT e.id, 'FUNCIONARIO'
    FROM public.entidades e
    JOIN public.vendedoras v 
      ON (e.documento IS NOT NULL AND e.documento = NULLIF(v.cpf,''))
      OR (e.documento IS NULL AND e.nome = v.nome)
    ON CONFLICT DO NOTHING;
  END IF;
END $$;

COMMIT;
SQL

# === 02) Views canônicas ===
cat > "supabase/migrations/${TS}_02_entity_selector_views.sql" <<'SQL'
-- financeirolb: views canônicas para consumo no front/BI
-- v1.0 - 2025-09-15

BEGIN;

-- Pessoas físicas ativas
CREATE OR REPLACE VIEW public.vw_pessoas_unificadas AS
SELECT e.*
FROM public.entidades e
WHERE e.tipo_pessoa = 'FISICA' AND e.ativo = TRUE;

-- Empresas (PJ) ativas
CREATE OR REPLACE VIEW public.vw_empresas_unificadas AS
SELECT e.*
FROM public.entidades e
WHERE e.tipo_pessoa = 'JURIDICA' AND e.ativo = TRUE;

-- Dimensão de entidades com flags de papéis
CREATE OR REPLACE VIEW public.vw_dim_entidade AS
SELECT 
  e.id AS entidade_id,
  e.nome,
  e.tipo_pessoa,
  e.documento,
  e.email,
  e.telefone,
  e.ativo,
  EXISTS (SELECT 1 FROM public.entidade_papel ep WHERE ep.entidade_id = e.id AND ep.papel = 'FORNECEDOR') AS is_fornecedor,
  EXISTS (SELECT 1 FROM public.entidade_papel ep WHERE ep.entidade_id = e.id AND ep.papel = 'CLIENTE') AS is_cliente,
  EXISTS (SELECT 1 FROM public.entidade_papel ep WHERE ep.entidade_id = e.id AND ep.papel = 'FUNCIONARIO') AS is_funcionario,
  e.criado_em,
  e.atualizado_em
FROM public.entidades e;

-- Vendedores (funcionários) ativos
CREATE OR REPLACE VIEW public.vw_vendedores_unificados AS
SELECT e.*
FROM public.entidades e
WHERE EXISTS (
  SELECT 1 FROM public.entidade_papel ep 
  WHERE ep.entidade_id = e.id AND ep.papel = 'FUNCIONARIO'
) AND e.ativo = TRUE;

COMMIT;
SQL

# === 03) Unicidade (CPF/CNPJ), índices e RLS básico ===
cat > "supabase/migrations/${TS}_03_uniques_indexes_policies.sql" <<'SQL'
-- financeirolb: unicidade (CPF/CNPJ), índices úteis e RLS básico
-- v1.0 - 2025-09-15

BEGIN;

-- Unicidade de documento quando não-nulo (CPF/CNPJ)
CREATE UNIQUE INDEX IF NOT EXISTS uq_entidades_documento_notnull
  ON public.entidades(documento) WHERE documento IS NOT NULL;

-- Índices auxiliares
CREATE INDEX IF NOT EXISTS idx_entidades_ativo ON public.entidades(ativo);
CREATE INDEX IF NOT EXISTS idx_entidade_papel_papel ON public.entidade_papel(papel);

-- Se a tabela nfe_data existir, cria chave única para chave de acesso
DO $$ BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.tables
    WHERE table_schema='public' AND table_name='nfe_data'
  ) THEN
    CREATE UNIQUE INDEX IF NOT EXISTS uq_nfe_data_chave ON public.nfe_data(chave_acesso);
  END IF;
END $$;

-- RLS básico (ajuste depois para organização/filial)
ALTER TABLE public.entidades ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.entidade_papel ENABLE ROW LEVEL SECURITY;

-- Função is_admin() (cria somente se não existir)
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 
    FROM pg_proc p 
    JOIN pg_namespace n ON n.oid = p.pronamespace
    WHERE p.proname = 'is_admin' AND n.nspname = 'public'
  ) THEN
    CREATE OR REPLACE FUNCTION public.is_admin()
    RETURNS boolean
    LANGUAGE sql STABLE
    AS $$
      select exists (
        select 1 from public.user_organizacoes uo
        where uo.user_id = auth.uid()
          and lower(coalesce(uo.role,'')) in ('admin','owner','superadmin')
      );
    $$;
  END IF;
END $$;

-- Policies (SELECT para autenticados; alterações só admin)
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='entidades' AND policyname='entidades_select_auth') THEN
    CREATE POLICY entidades_select_auth ON public.entidades
      FOR SELECT TO authenticated USING (true);
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='entidades' AND policyname='entidades_mod_admin') THEN
    CREATE POLICY entidades_mod_admin ON public.entidades
      FOR ALL TO authenticated
      USING (public.is_admin()) WITH CHECK (public.is_admin());
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='entidade_papel' AND policyname='entidade_papel_select_auth') THEN
    CREATE POLICY entidade_papel_select_auth ON public.entidade_papel
      FOR SELECT TO authenticated USING (true);
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='entidade_papel' AND policyname='entidade_papel_mod_admin') THEN
    CREATE POLICY entidade_papel_mod_admin ON public.entidade_papel
      FOR ALL TO authenticated
      USING (public.is_admin()) WITH CHECK (public.is_admin());
  END IF;
END $$;

COMMIT;
SQL

# === 04) Recorrentes (cadastro + função + agendamento) ===
cat > "supabase/migrations/${TS}_04_recorrentes_fn_cron.sql" <<'SQL'
-- financeirolb: recorrentes (cadastro + função + agendamento)
-- v1.0 - 2025-09-15

BEGIN;

-- Cadastro de recorrentes (se ainda não existir)
CREATE TABLE IF NOT EXISTS public.recorrentes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  filial_id BIGINT,
  credor_id BIGINT REFERENCES public.entidades(id),
  categoria_id BIGINT,
  descricao TEXT NOT NULL,
  valor NUMERIC(14,2) NOT NULL CHECK (valor >= 0),
  dia_vencimento INT NOT NULL CHECK (dia_vencimento BETWEEN 1 AND 28),
  ativo BOOLEAN NOT NULL DEFAULT TRUE,
  criado_em TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.recorrentes_log (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ano INT NOT NULL,
  mes INT NOT NULL CHECK (mes BETWEEN 1 AND 12),
  executado_em TIMESTAMPTZ NOT NULL DEFAULT now(),
  total_gerado INT NOT NULL
);

-- Função que gera os lançamentos do mês/ano
CREATE OR REPLACE FUNCTION public.gerar_recorrentes(pano INT, pmes INT)
RETURNS VOID
LANGUAGE plpgsql
AS $$
DECLARE 
  rec RECORD;
  nova_conta_id BIGINT;
  venc DATE;
BEGIN
  FOR rec IN 
    SELECT * FROM public.recorrentes WHERE ativo = TRUE
  LOOP
    venc := make_date(pano, pmes, rec.dia_vencimento);

    -- cria título (cabeçalho) se existir a tabela; caso não exista, apenas loga
    IF EXISTS (
      SELECT 1 FROM information_schema.tables
      WHERE table_schema='public' AND table_name='contas_pagar_corporativas'
    ) THEN
      INSERT INTO public.contas_pagar_corporativas (filial_id, credor_id, descricao, valor_total, categoria_id, dt_vencimento)
      VALUES (rec.filial_id, rec.credor_id, concat(rec.descricao, ' ', to_char(venc, 'MM/YYYY')), rec.valor, rec.categoria_id, venc)
      RETURNING id INTO nova_conta_id;

      -- cria parcela (se existir a tabela)
      IF EXISTS (
        SELECT 1 FROM information_schema.tables
        WHERE table_schema='public' AND table_name='parcelas_conta_pagar'
      ) THEN
        INSERT INTO public.parcelas_conta_pagar (conta_pagar_id, data_vencimento, valor_parcela, status)
        VALUES (nova_conta_id, venc, rec.valor, 'a_vencer');
      END IF;
    END IF;
  END LOOP;

  INSERT INTO public.recorrentes_log (ano, mes, total_gerado)
  VALUES (pano, pmes, (SELECT COUNT(*) FROM public.recorrentes WHERE ativo = TRUE));
END;
$$;

COMMIT;

-- Extensão de agendamento (Supabase usa schema 'extensions')
CREATE EXTENSION IF NOT EXISTS pg_cron WITH SCHEMA extensions;

-- Agenda todo dia 1 às 00:10
SELECT extensions.cron.schedule(
  'financeirolb_recorrentes_mensal',
  '10 0 1 * *',
  $$ SELECT public.gerar_recorrentes(EXTRACT(year FROM current_date)::int, EXTRACT(month FROM current_date)::int) $$
);
SQL

# === Seeds CSV (Excel macOS ; ) ===
cat > "data/seed/entidades_modelo.csv" <<'CSV'
tipo_pessoa;nome;documento;email;telefone;ativo
JURIDICA;Lui Bambini Matriz Ltda;12345678000199;financeiro@luibambini.com;11999990000;TRUE
FISICA;Maria Vendedora;12345678901;maria.vendas@luibambini.com;11988887777;TRUE
CSV

cat > "data/seed/entidade_papel_modelo.csv" <<'CSV'
documento;papel
12345678000199;FORNECEDOR
12345678901;FUNCIONARIO
CSV

# === Docs simples ===
cat > "README.md" <<'MD'
# FinanceiroLB v2 — Estrutura pronta (migrations + seeds)

- **supabase/migrations/**: 4 migrations idempotentes (entidades/papéis, views, unicidade/índices/RLS, recorrentes).
- **data/seed/**: CSVs (Excel macOS ;).
- **docs/README_MIGRATIONS.md**: como aplicar e validar.
MD

cat > "docs/README_MIGRATIONS.md" <<'MD'
# Guia — Aplicar migrations e validar

## 1) Aplicar migrations (Supabase CLI)
```bash
npx supabase link --project-ref https://jcasmmedljaglyjamjab.supabase.co
npx supabase db push
